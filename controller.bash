#!/usr/bin/env bash
set -euo pipefail

# Blog Notes:
#
# first pass: using unstructured logging
# second pass: using JSON for structured logging
# note that errors generated by the API will not
# be captured by logging and will look messy. in a production situation where logs are being sent
# to an aggregator, this will lead to cluttered
# and hard-to-correlate log entries.
log() {
  local level message message_downcase timestamp format
  level="$1"
  message="$2"
  message_downcase="$(tr '[:upper:]' '[:lower:]' <<< "$message")"
  timestamp="$(date +%s)"
  format='[%s][%s] %s'
  use_json_logging && 
    format='{"time":"%s","level":"%s","message":"%s"}'

  # shellcheck disable=SC2059
  printf "$format" "$timestamp" "$level" "$message_downcase"
}

log_error() {
  log 'ERROR' "$1"
}

log_info() {
  log 'INFO' "$1"
}

watcher_pod_annotation_key() {
  local watcher

  watcher="$1"
  echo 'WIP'
}

watcher_pod_annotation_val() {
  local watcher

  watcher="$1"
  echo 'WIP'
}

locate_interesting_pods() {
  local k v
  k="$1"
  v="$2"
  echo "WIP"
}

print_pod_state() {
  local pod
  pod="$1"

  echo "WIP"
}

mark_pod_as_seen() {
  local pod
  pod="$1"

  echo "WIP"
}

mark_podwatcher_last_run() {
  local w
  w="$1"

  echo "WIP"
}
# Blog Notes: Explain how most controllers
# are just watching the Kubernetes API and doing
# things based on API events, and that we
# can use `kubectl` as a shortcut.
#
# (If we were hardcore, we'd use `curl` directly...
# but we're lazy.)
kubeconfig() {
  [[ -n "$KUBECONFIG" ]] && \
    echo "$KUBECONFIG" ||
    echo "$HOME/.kube/config"
}

# Blog Note:
#
# Controllers should do the following until they
# encounter an unrecoverable error or are terminated manually:
#
# - Find CRs that it manages or resources it cares about
# - Do things or reconcile the thing (i.e. bring the thing to a desired state)
# - Sleep
#
# That's it! A ltitle less magical, right?
#
# "Reconciliation" for our basic controller here is basically tagging each Pod as having been seen
# by our watcher and then marking the PodWatcher's last run time.
#
# More advanced controllers, like the ClusterAPI
# controllers, might call external APIs during this step.
exec_controller_loop() {
  if ! watchers_json=$(get_watchers_in_cluster)
  then
    log_error "Unable to fetch watchers."
    exit 1
  fi
  for watcher in $(watcher_names "$watchers_json")
  do
    log_info "Processing watcher '$watcher'"
    wanted_pod_label_key=$(watcher_pod_annotation_key "$watcher")
    wanted_pod_label_val=$(watcher_pod_annotation_val "$watcher")
    log_info "Looking for Pods with '${wanted_pod_label_key}' -> '${wanted_pod_label_val}'"
    if ! found_pods=$(locate_interesting_pods "$wanted_pod_label_key" "$wanted_pod_label_val")
    then
      log_error "An error occurred while looking for Pods"
      exit 1
    fi
    found_pod_count=$"(wc -l <<< "$found_pods")"
    log_info "${found_pod_count} interesting pods found"
    for pod in $found_pods
    do
      print_pod_state "$pod" &&
        mark_pod_as_seen "$pod"
    done
    mark_podwatcher_last_run "$watcher"
    log_info "Watcher '$watcher' processed"
  done
}

if ! ensure_kubernetes_api_reachable "$(kubeconfig)"
then
  log_error "Kubernetes API not reachable."
  exit 1
fi
while true
do
  log_info "bash controller started and will poll every mninute; send SIGHUP to exit"
  exec_controller_loop || exit 1
  sleep 60
done
